{"ast":null,"code":"import { useRef, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport ReactDOM from 'react-dom';\nimport canUseDom from \"./Dom/canUseDom\";\nvar Portal = /*#__PURE__*/forwardRef(function (props, ref) {\n  var didUpdate = props.didUpdate,\n      getContainer = props.getContainer,\n      children = props.children;\n  var parentRef = useRef();\n  var containerRef = useRef(); // Ref return nothing, only for wrapper check exist\n\n  useImperativeHandle(ref, function () {\n    return {};\n  }); // Create container in client side with sync to avoid useEffect not get ref\n\n  var initRef = useRef(false);\n\n  if (!initRef.current && canUseDom()) {\n    containerRef.current = getContainer();\n    parentRef.current = containerRef.current.parentNode;\n    initRef.current = true;\n  } // [Legacy] Used by `rc-trigger`\n\n\n  useEffect(function () {\n    didUpdate === null || didUpdate === void 0 || didUpdate(props);\n  });\n  useEffect(function () {\n    // Restore container to original place\n    // React 18 StrictMode will unmount first and mount back for effect test:\n    // https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors\n    if (containerRef.current.parentNode === null && parentRef.current !== null) {\n      parentRef.current.appendChild(containerRef.current);\n    }\n\n    return function () {\n      var _containerRef$current; // [Legacy] This should not be handle by Portal but parent PortalWrapper instead.\n      // Since some component use `Portal` directly, we have to keep the logic here.\n\n\n      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 || (_containerRef$current = _containerRef$current.parentNode) === null || _containerRef$current === void 0 || _containerRef$current.removeChild(containerRef.current);\n    };\n  }, []);\n  return containerRef.current ? /*#__PURE__*/ReactDOM.createPortal(children, containerRef.current) : null;\n});\nexport default Portal;","map":{"version":3,"sources":["C:/Users/vyshn/OneDrive/Desktop/Mern project/CarDhundo/client/node_modules/rc-util/es/Portal.js"],"names":["useRef","useEffect","forwardRef","useImperativeHandle","ReactDOM","canUseDom","Portal","props","ref","didUpdate","getContainer","children","parentRef","containerRef","initRef","current","parentNode","appendChild","_containerRef$current","removeChild","createPortal"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,SAAjB,EAA4BC,UAA5B,EAAwCC,mBAAxC,QAAmE,OAAnE;AACA,OAAOC,QAAP,MAAqB,WAArB;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,IAAIC,MAAM,GAAG,aAAaJ,UAAU,CAAC,UAAUK,KAAV,EAAiBC,GAAjB,EAAsB;AACzD,MAAIC,SAAS,GAAGF,KAAK,CAACE,SAAtB;AAAA,MACEC,YAAY,GAAGH,KAAK,CAACG,YADvB;AAAA,MAEEC,QAAQ,GAAGJ,KAAK,CAACI,QAFnB;AAGA,MAAIC,SAAS,GAAGZ,MAAM,EAAtB;AACA,MAAIa,YAAY,GAAGb,MAAM,EAAzB,CALyD,CAOzD;;AACAG,EAAAA,mBAAmB,CAACK,GAAD,EAAM,YAAY;AACnC,WAAO,EAAP;AACD,GAFkB,CAAnB,CARyD,CAYzD;;AACA,MAAIM,OAAO,GAAGd,MAAM,CAAC,KAAD,CAApB;;AACA,MAAI,CAACc,OAAO,CAACC,OAAT,IAAoBV,SAAS,EAAjC,EAAqC;AACnCQ,IAAAA,YAAY,CAACE,OAAb,GAAuBL,YAAY,EAAnC;AACAE,IAAAA,SAAS,CAACG,OAAV,GAAoBF,YAAY,CAACE,OAAb,CAAqBC,UAAzC;AACAF,IAAAA,OAAO,CAACC,OAAR,GAAkB,IAAlB;AACD,GAlBwD,CAoBzD;;;AACAd,EAAAA,SAAS,CAAC,YAAY;AACpBQ,IAAAA,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,IAA8CA,SAAS,CAACF,KAAD,CAAvD;AACD,GAFQ,CAAT;AAGAN,EAAAA,SAAS,CAAC,YAAY;AACpB;AACA;AACA;AACA,QAAIY,YAAY,CAACE,OAAb,CAAqBC,UAArB,KAAoC,IAApC,IAA4CJ,SAAS,CAACG,OAAV,KAAsB,IAAtE,EAA4E;AAC1EH,MAAAA,SAAS,CAACG,OAAV,CAAkBE,WAAlB,CAA8BJ,YAAY,CAACE,OAA3C;AACD;;AACD,WAAO,YAAY;AACjB,UAAIG,qBAAJ,CADiB,CAEjB;AACA;;;AACA,OAACA,qBAAqB,GAAGL,YAAY,CAACE,OAAtC,MAAmD,IAAnD,IAA2DG,qBAAqB,KAAK,KAAK,CAA1F,IAA+F,CAACA,qBAAqB,GAAGA,qBAAqB,CAACF,UAA/C,MAA+D,IAA9J,IAAsKE,qBAAqB,KAAK,KAAK,CAArM,IAA0MA,qBAAqB,CAACC,WAAtB,CAAkCN,YAAY,CAACE,OAA/C,CAA1M;AACD,KALD;AAMD,GAbQ,EAaN,EAbM,CAAT;AAcA,SAAOF,YAAY,CAACE,OAAb,GAAuB,aAAaX,QAAQ,CAACgB,YAAT,CAAsBT,QAAtB,EAAgCE,YAAY,CAACE,OAA7C,CAApC,GAA4F,IAAnG;AACD,CAvCmC,CAApC;AAwCA,eAAeT,MAAf","sourcesContent":["import { useRef, useEffect, forwardRef, useImperativeHandle } from 'react';\nimport ReactDOM from 'react-dom';\nimport canUseDom from \"./Dom/canUseDom\";\nvar Portal = /*#__PURE__*/forwardRef(function (props, ref) {\n  var didUpdate = props.didUpdate,\n    getContainer = props.getContainer,\n    children = props.children;\n  var parentRef = useRef();\n  var containerRef = useRef();\n\n  // Ref return nothing, only for wrapper check exist\n  useImperativeHandle(ref, function () {\n    return {};\n  });\n\n  // Create container in client side with sync to avoid useEffect not get ref\n  var initRef = useRef(false);\n  if (!initRef.current && canUseDom()) {\n    containerRef.current = getContainer();\n    parentRef.current = containerRef.current.parentNode;\n    initRef.current = true;\n  }\n\n  // [Legacy] Used by `rc-trigger`\n  useEffect(function () {\n    didUpdate === null || didUpdate === void 0 || didUpdate(props);\n  });\n  useEffect(function () {\n    // Restore container to original place\n    // React 18 StrictMode will unmount first and mount back for effect test:\n    // https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors\n    if (containerRef.current.parentNode === null && parentRef.current !== null) {\n      parentRef.current.appendChild(containerRef.current);\n    }\n    return function () {\n      var _containerRef$current;\n      // [Legacy] This should not be handle by Portal but parent PortalWrapper instead.\n      // Since some component use `Portal` directly, we have to keep the logic here.\n      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 || (_containerRef$current = _containerRef$current.parentNode) === null || _containerRef$current === void 0 || _containerRef$current.removeChild(containerRef.current);\n    };\n  }, []);\n  return containerRef.current ? /*#__PURE__*/ReactDOM.createPortal(children, containerRef.current) : null;\n});\nexport default Portal;"]},"metadata":{},"sourceType":"module"}