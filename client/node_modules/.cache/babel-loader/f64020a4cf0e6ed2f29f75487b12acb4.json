{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n/* eslint-disable no-param-reassign */\n\nimport * as React from 'react';\nimport raf from \"rc-util/es/raf\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport { warning } from 'rc-util';\nvar MAX_TIMES = 10;\nexport default function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  var scrollRef = React.useRef();\n\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      syncState = _React$useState2[0],\n      setSyncState = _React$useState2[1]; // ========================== Sync Scroll ==========================\n\n\n  useLayoutEffect(function () {\n    if (syncState && syncState.times < MAX_TIMES) {\n      // Never reach\n      if (!containerRef.current) {\n        setSyncState(function (ori) {\n          return _objectSpread({}, ori);\n        });\n        return;\n      }\n\n      collectHeight();\n      var targetAlign = syncState.targetAlign,\n          originAlign = syncState.originAlign,\n          index = syncState.index,\n          offset = syncState.offset;\n      var height = containerRef.current.clientHeight;\n      var needCollectHeight = false;\n      var newTargetAlign = targetAlign;\n      var targetTop = null; // Go to next frame if height not exist\n\n      if (height) {\n        var mergedAlign = targetAlign || originAlign; // Get top & bottom\n\n        var stackTop = 0;\n        var itemTop = 0;\n        var itemBottom = 0;\n        var maxLen = Math.min(data.length - 1, index);\n\n        for (var i = 0; i <= maxLen; i += 1) {\n          var key = getKey(data[i]);\n          itemTop = stackTop;\n          var cacheHeight = heights.get(key);\n          itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n          stackTop = itemBottom;\n        } // Check if need sync height (visible range has item not record height)\n\n\n        var leftHeight = mergedAlign === 'top' ? offset : height - offset;\n\n        for (var _i = maxLen; _i >= 0; _i -= 1) {\n          var _key = getKey(data[_i]);\n\n          var _cacheHeight = heights.get(_key);\n\n          if (_cacheHeight === undefined) {\n            needCollectHeight = true;\n            break;\n          }\n\n          leftHeight -= _cacheHeight;\n\n          if (leftHeight <= 0) {\n            break;\n          }\n        } // Scroll to\n\n\n        switch (mergedAlign) {\n          case 'top':\n            targetTop = itemTop - offset;\n            break;\n\n          case 'bottom':\n            targetTop = itemBottom - height + offset;\n            break;\n\n          default:\n            {\n              var scrollTop = containerRef.current.scrollTop;\n              var scrollBottom = scrollTop + height;\n\n              if (itemTop < scrollTop) {\n                newTargetAlign = 'top';\n              } else if (itemBottom > scrollBottom) {\n                newTargetAlign = 'bottom';\n              }\n            }\n        }\n\n        if (targetTop !== null) {\n          syncScrollTop(targetTop);\n        } // One more time for sync\n\n\n        if (targetTop !== syncState.lastTop) {\n          needCollectHeight = true;\n        }\n      } // Trigger next effect\n\n\n      if (needCollectHeight) {\n        setSyncState(_objectSpread(_objectSpread({}, syncState), {}, {\n          times: syncState.times + 1,\n          targetAlign: newTargetAlign,\n          lastTop: targetTop\n        }));\n      }\n    } else if (process.env.NODE_ENV !== 'production' && (syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) {\n      warning(false, 'Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.');\n    }\n  }, [syncState, containerRef.current]); // =========================== Scroll To ===========================\n\n  return function (arg) {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    } // Normal scroll logic\n\n\n    raf.cancel(scrollRef.current);\n\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && _typeof(arg) === 'object') {\n      var index;\n      var align = arg.align;\n\n      if ('index' in arg) {\n        index = arg.index;\n      } else {\n        index = data.findIndex(function (item) {\n          return getKey(item) === arg.key;\n        });\n      }\n\n      var _arg$offset = arg.offset,\n          offset = _arg$offset === void 0 ? 0 : _arg$offset;\n      setSyncState({\n        times: 0,\n        index: index,\n        offset: offset,\n        originAlign: align\n      });\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/vyshn/OneDrive/Desktop/Mern project/CarDhundo/client/node_modules/rc-virtual-list/es/hooks/useScrollTo.js"],"names":["_typeof","_objectSpread","_slicedToArray","React","raf","useLayoutEffect","warning","MAX_TIMES","useScrollTo","containerRef","data","heights","itemHeight","getKey","collectHeight","syncScrollTop","triggerFlash","scrollRef","useRef","_React$useState","useState","_React$useState2","syncState","setSyncState","times","current","ori","targetAlign","originAlign","index","offset","height","clientHeight","needCollectHeight","newTargetAlign","targetTop","mergedAlign","stackTop","itemTop","itemBottom","maxLen","Math","min","length","i","key","cacheHeight","get","undefined","leftHeight","_i","_key","_cacheHeight","scrollTop","scrollBottom","lastTop","process","env","NODE_ENV","arg","cancel","align","findIndex","item","_arg$offset"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,mCAApB;AACA,OAAOC,aAAP,MAA0B,0CAA1B;AACA,OAAOC,cAAP,MAA2B,0CAA3B;AACA;;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAOC,GAAP,MAAgB,gBAAhB;AACA,OAAOC,eAAP,MAA4B,kCAA5B;AACA,SAASC,OAAT,QAAwB,SAAxB;AACA,IAAIC,SAAS,GAAG,EAAhB;AACA,eAAe,SAASC,WAAT,CAAqBC,YAArB,EAAmCC,IAAnC,EAAyCC,OAAzC,EAAkDC,UAAlD,EAA8DC,MAA9D,EAAsEC,aAAtE,EAAqFC,aAArF,EAAoGC,YAApG,EAAkH;AAC/H,MAAIC,SAAS,GAAGd,KAAK,CAACe,MAAN,EAAhB;;AACA,MAAIC,eAAe,GAAGhB,KAAK,CAACiB,QAAN,CAAe,IAAf,CAAtB;AAAA,MACEC,gBAAgB,GAAGnB,cAAc,CAACiB,eAAD,EAAkB,CAAlB,CADnC;AAAA,MAEEG,SAAS,GAAGD,gBAAgB,CAAC,CAAD,CAF9B;AAAA,MAGEE,YAAY,GAAGF,gBAAgB,CAAC,CAAD,CAHjC,CAF+H,CAM/H;;;AACAhB,EAAAA,eAAe,CAAC,YAAY;AAC1B,QAAIiB,SAAS,IAAIA,SAAS,CAACE,KAAV,GAAkBjB,SAAnC,EAA8C;AAC5C;AACA,UAAI,CAACE,YAAY,CAACgB,OAAlB,EAA2B;AACzBF,QAAAA,YAAY,CAAC,UAAUG,GAAV,EAAe;AAC1B,iBAAOzB,aAAa,CAAC,EAAD,EAAKyB,GAAL,CAApB;AACD,SAFW,CAAZ;AAGA;AACD;;AACDZ,MAAAA,aAAa;AACb,UAAIa,WAAW,GAAGL,SAAS,CAACK,WAA5B;AAAA,UACEC,WAAW,GAAGN,SAAS,CAACM,WAD1B;AAAA,UAEEC,KAAK,GAAGP,SAAS,CAACO,KAFpB;AAAA,UAGEC,MAAM,GAAGR,SAAS,CAACQ,MAHrB;AAIA,UAAIC,MAAM,GAAGtB,YAAY,CAACgB,OAAb,CAAqBO,YAAlC;AACA,UAAIC,iBAAiB,GAAG,KAAxB;AACA,UAAIC,cAAc,GAAGP,WAArB;AACA,UAAIQ,SAAS,GAAG,IAAhB,CAhB4C,CAiB5C;;AACA,UAAIJ,MAAJ,EAAY;AACV,YAAIK,WAAW,GAAGT,WAAW,IAAIC,WAAjC,CADU,CAEV;;AACA,YAAIS,QAAQ,GAAG,CAAf;AACA,YAAIC,OAAO,GAAG,CAAd;AACA,YAAIC,UAAU,GAAG,CAAjB;AACA,YAAIC,MAAM,GAAGC,IAAI,CAACC,GAAL,CAAShC,IAAI,CAACiC,MAAL,GAAc,CAAvB,EAA0Bd,KAA1B,CAAb;;AACA,aAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIJ,MAArB,EAA6BI,CAAC,IAAI,CAAlC,EAAqC;AACnC,cAAIC,GAAG,GAAGhC,MAAM,CAACH,IAAI,CAACkC,CAAD,CAAL,CAAhB;AACAN,UAAAA,OAAO,GAAGD,QAAV;AACA,cAAIS,WAAW,GAAGnC,OAAO,CAACoC,GAAR,CAAYF,GAAZ,CAAlB;AACAN,UAAAA,UAAU,GAAGD,OAAO,IAAIQ,WAAW,KAAKE,SAAhB,GAA4BpC,UAA5B,GAAyCkC,WAA7C,CAApB;AACAT,UAAAA,QAAQ,GAAGE,UAAX;AACD,SAbS,CAcV;;;AACA,YAAIU,UAAU,GAAGb,WAAW,KAAK,KAAhB,GAAwBN,MAAxB,GAAiCC,MAAM,GAAGD,MAA3D;;AACA,aAAK,IAAIoB,EAAE,GAAGV,MAAd,EAAsBU,EAAE,IAAI,CAA5B,EAA+BA,EAAE,IAAI,CAArC,EAAwC;AACtC,cAAIC,IAAI,GAAGtC,MAAM,CAACH,IAAI,CAACwC,EAAD,CAAL,CAAjB;;AACA,cAAIE,YAAY,GAAGzC,OAAO,CAACoC,GAAR,CAAYI,IAAZ,CAAnB;;AACA,cAAIC,YAAY,KAAKJ,SAArB,EAAgC;AAC9Bf,YAAAA,iBAAiB,GAAG,IAApB;AACA;AACD;;AACDgB,UAAAA,UAAU,IAAIG,YAAd;;AACA,cAAIH,UAAU,IAAI,CAAlB,EAAqB;AACnB;AACD;AACF,SA3BS,CA4BV;;;AACA,gBAAQb,WAAR;AACE,eAAK,KAAL;AACED,YAAAA,SAAS,GAAGG,OAAO,GAAGR,MAAtB;AACA;;AACF,eAAK,QAAL;AACEK,YAAAA,SAAS,GAAGI,UAAU,GAAGR,MAAb,GAAsBD,MAAlC;AACA;;AACF;AACE;AACE,kBAAIuB,SAAS,GAAG5C,YAAY,CAACgB,OAAb,CAAqB4B,SAArC;AACA,kBAAIC,YAAY,GAAGD,SAAS,GAAGtB,MAA/B;;AACA,kBAAIO,OAAO,GAAGe,SAAd,EAAyB;AACvBnB,gBAAAA,cAAc,GAAG,KAAjB;AACD,eAFD,MAEO,IAAIK,UAAU,GAAGe,YAAjB,EAA+B;AACpCpB,gBAAAA,cAAc,GAAG,QAAjB;AACD;AACF;AAhBL;;AAkBA,YAAIC,SAAS,KAAK,IAAlB,EAAwB;AACtBpB,UAAAA,aAAa,CAACoB,SAAD,CAAb;AACD,SAjDS,CAkDV;;;AACA,YAAIA,SAAS,KAAKb,SAAS,CAACiC,OAA5B,EAAqC;AACnCtB,UAAAA,iBAAiB,GAAG,IAApB;AACD;AACF,OAxE2C,CAyE5C;;;AACA,UAAIA,iBAAJ,EAAuB;AACrBV,QAAAA,YAAY,CAACtB,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKqB,SAAL,CAAd,EAA+B,EAA/B,EAAmC;AAC3DE,UAAAA,KAAK,EAAEF,SAAS,CAACE,KAAV,GAAkB,CADkC;AAE3DG,UAAAA,WAAW,EAAEO,cAF8C;AAG3DqB,UAAAA,OAAO,EAAEpB;AAHkD,SAAnC,CAAd,CAAZ;AAKD;AACF,KAjFD,MAiFO,IAAIqB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyC,CAACpC,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACE,KAAjE,MAA4EjB,SAAzH,EAAoI;AACzID,MAAAA,OAAO,CAAC,KAAD,EAAQ,qGAAR,CAAP;AACD;AACF,GArFc,EAqFZ,CAACgB,SAAD,EAAYb,YAAY,CAACgB,OAAzB,CArFY,CAAf,CAP+H,CA6F/H;;AACA,SAAO,UAAUkC,GAAV,EAAe;AACpB;AACA,QAAIA,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAKX,SAA5B,EAAuC;AACrChC,MAAAA,YAAY;AACZ;AACD,KALmB,CAMpB;;;AACAZ,IAAAA,GAAG,CAACwD,MAAJ,CAAW3C,SAAS,CAACQ,OAArB;;AACA,QAAI,OAAOkC,GAAP,KAAe,QAAnB,EAA6B;AAC3B5C,MAAAA,aAAa,CAAC4C,GAAD,CAAb;AACD,KAFD,MAEO,IAAIA,GAAG,IAAI3D,OAAO,CAAC2D,GAAD,CAAP,KAAiB,QAA5B,EAAsC;AAC3C,UAAI9B,KAAJ;AACA,UAAIgC,KAAK,GAAGF,GAAG,CAACE,KAAhB;;AACA,UAAI,WAAWF,GAAf,EAAoB;AAClB9B,QAAAA,KAAK,GAAG8B,GAAG,CAAC9B,KAAZ;AACD,OAFD,MAEO;AACLA,QAAAA,KAAK,GAAGnB,IAAI,CAACoD,SAAL,CAAe,UAAUC,IAAV,EAAgB;AACrC,iBAAOlD,MAAM,CAACkD,IAAD,CAAN,KAAiBJ,GAAG,CAACd,GAA5B;AACD,SAFO,CAAR;AAGD;;AACD,UAAImB,WAAW,GAAGL,GAAG,CAAC7B,MAAtB;AAAA,UACEA,MAAM,GAAGkC,WAAW,KAAK,KAAK,CAArB,GAAyB,CAAzB,GAA6BA,WADxC;AAEAzC,MAAAA,YAAY,CAAC;AACXC,QAAAA,KAAK,EAAE,CADI;AAEXK,QAAAA,KAAK,EAAEA,KAFI;AAGXC,QAAAA,MAAM,EAAEA,MAHG;AAIXF,QAAAA,WAAW,EAAEiC;AAJF,OAAD,CAAZ;AAMD;AACF,GA7BD;AA8BD","sourcesContent":["import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n/* eslint-disable no-param-reassign */\nimport * as React from 'react';\nimport raf from \"rc-util/es/raf\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport { warning } from 'rc-util';\nvar MAX_TIMES = 10;\nexport default function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  var scrollRef = React.useRef();\n  var _React$useState = React.useState(null),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    syncState = _React$useState2[0],\n    setSyncState = _React$useState2[1];\n  // ========================== Sync Scroll ==========================\n  useLayoutEffect(function () {\n    if (syncState && syncState.times < MAX_TIMES) {\n      // Never reach\n      if (!containerRef.current) {\n        setSyncState(function (ori) {\n          return _objectSpread({}, ori);\n        });\n        return;\n      }\n      collectHeight();\n      var targetAlign = syncState.targetAlign,\n        originAlign = syncState.originAlign,\n        index = syncState.index,\n        offset = syncState.offset;\n      var height = containerRef.current.clientHeight;\n      var needCollectHeight = false;\n      var newTargetAlign = targetAlign;\n      var targetTop = null;\n      // Go to next frame if height not exist\n      if (height) {\n        var mergedAlign = targetAlign || originAlign;\n        // Get top & bottom\n        var stackTop = 0;\n        var itemTop = 0;\n        var itemBottom = 0;\n        var maxLen = Math.min(data.length - 1, index);\n        for (var i = 0; i <= maxLen; i += 1) {\n          var key = getKey(data[i]);\n          itemTop = stackTop;\n          var cacheHeight = heights.get(key);\n          itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n          stackTop = itemBottom;\n        }\n        // Check if need sync height (visible range has item not record height)\n        var leftHeight = mergedAlign === 'top' ? offset : height - offset;\n        for (var _i = maxLen; _i >= 0; _i -= 1) {\n          var _key = getKey(data[_i]);\n          var _cacheHeight = heights.get(_key);\n          if (_cacheHeight === undefined) {\n            needCollectHeight = true;\n            break;\n          }\n          leftHeight -= _cacheHeight;\n          if (leftHeight <= 0) {\n            break;\n          }\n        }\n        // Scroll to\n        switch (mergedAlign) {\n          case 'top':\n            targetTop = itemTop - offset;\n            break;\n          case 'bottom':\n            targetTop = itemBottom - height + offset;\n            break;\n          default:\n            {\n              var scrollTop = containerRef.current.scrollTop;\n              var scrollBottom = scrollTop + height;\n              if (itemTop < scrollTop) {\n                newTargetAlign = 'top';\n              } else if (itemBottom > scrollBottom) {\n                newTargetAlign = 'bottom';\n              }\n            }\n        }\n        if (targetTop !== null) {\n          syncScrollTop(targetTop);\n        }\n        // One more time for sync\n        if (targetTop !== syncState.lastTop) {\n          needCollectHeight = true;\n        }\n      }\n      // Trigger next effect\n      if (needCollectHeight) {\n        setSyncState(_objectSpread(_objectSpread({}, syncState), {}, {\n          times: syncState.times + 1,\n          targetAlign: newTargetAlign,\n          lastTop: targetTop\n        }));\n      }\n    } else if (process.env.NODE_ENV !== 'production' && (syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) {\n      warning(false, 'Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.');\n    }\n  }, [syncState, containerRef.current]);\n  // =========================== Scroll To ===========================\n  return function (arg) {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    }\n    // Normal scroll logic\n    raf.cancel(scrollRef.current);\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && _typeof(arg) === 'object') {\n      var index;\n      var align = arg.align;\n      if ('index' in arg) {\n        index = arg.index;\n      } else {\n        index = data.findIndex(function (item) {\n          return getKey(item) === arg.key;\n        });\n      }\n      var _arg$offset = arg.offset,\n        offset = _arg$offset === void 0 ? 0 : _arg$offset;\n      setSyncState({\n        times: 0,\n        index: index,\n        offset: offset,\n        originAlign: align\n      });\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}